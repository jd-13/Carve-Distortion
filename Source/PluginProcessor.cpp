/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <string>


//==============================================================================
CarveAudioProcessor::CarveAudioProcessor()
{
    namespace CP = WECore::Carve::Parameters;

    constexpr float PRECISION {0.01f};

    registerParameter(mode1, MODE1_STR, &CP::MODE, CP::MODE.defaultValue);
    registerParameter(preGain1, PREGAIN1_STR, &CP::PREGAIN, CP::PREGAIN.defaultValue, PRECISION);
    registerParameter(postGain1, POSTGAIN1_STR, &CP::POSTGAIN, CP::POSTGAIN.defaultValue, PRECISION);
    registerParameter(tweak1, TWEAK1_STR, &CP::TWEAK, CP::TWEAK.defaultValue, PRECISION);

    registerParameter(mode2, MODE2_STR, &CP::MODE, CP::MODE.defaultValue);
    registerParameter(preGain2, PREGAIN2_STR, &CP::PREGAIN, CP::PREGAIN.defaultValue, PRECISION);
    registerParameter(postGain2, POSTGAIN2_STR, &CP::POSTGAIN, CP::POSTGAIN.defaultValue, PRECISION);
    registerParameter(tweak2, TWEAK2_STR, &CP::TWEAK, CP::TWEAK.defaultValue, PRECISION);

    registerParameter(routing, ROUTING_STR, &ROUTING, ROUTING.defaultValue, PRECISION);
    registerParameter(stereo, STEREO_STR, STEREO_DEFAULT);
    registerParameter(dryLevel, DRYLEVEL_STR, &DRYLEVEL, DRYLEVEL.defaultValue, PRECISION);
    registerParameter(outputGain, OUTPUTGAIN_STR, &OUTPUTGAIN, OUTPUTGAIN.defaultValue, PRECISION);
}

CarveAudioProcessor::~CarveAudioProcessor()
{
}

//==============================================================================
const String CarveAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String CarveAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String CarveAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool CarveAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool CarveAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool CarveAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool CarveAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool CarveAudioProcessor::silenceInProducesSilenceOut() const
{
    return true;
}

double CarveAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int CarveAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int CarveAudioProcessor::getCurrentProgram()
{
    return 0;
}

void CarveAudioProcessor::setCurrentProgram (int index)
{
}

const String CarveAudioProcessor::getProgramName (int index)
{
    return String();
}

void CarveAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void CarveAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    mCarve.reset();
    mCarve.setSampleRate(sampleRate);
}

void CarveAudioProcessor::releaseResources()
{
    mCarve.reset();
}

void CarveAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    const int totalNumInputChannels  = getTotalNumInputChannels();
    const int totalNumOutputChannels = getTotalNumOutputChannels();

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = totalNumInputChannels; i < totalNumOutputChannels; ++i) {
        buffer.clear (i, 0, buffer.getNumSamples());
    }

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    if (totalNumOutputChannels == 1 && totalNumOutputChannels == 1) {

        float* inSample {buffer.getWritePointer(0)};
        mCarve.Process1in1out(inSample, buffer.getNumSamples());

    } else if (totalNumInputChannels == 1 && totalNumOutputChannels == 2) {

        float* inLeftSample {buffer.getWritePointer(0)};
        float* inRightSample {buffer.getWritePointer(1)};

        mCarve.Process1in2out(inLeftSample, inRightSample, buffer.getNumSamples());

    } else {

        float* inLeftSample {buffer.getWritePointer(0)};
        float* inRightSample {buffer.getWritePointer(1)};

        mCarve.Process2in2out(inLeftSample, inRightSample, buffer.getNumSamples());
    }
}

//==============================================================================
bool CarveAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* CarveAudioProcessor::createEditor()
{
    return new CarveAudioProcessorEditor (*this);
}

//==============================================================================
void CarveAudioProcessor::setStereo(bool val) {
    // This is called from _onParameterUpdate so only proceed if the value has actually changed,
    // otherwise it will cause an infinite loop
    if (val != mCarve.getStereo()) {
        if (getNumOutputChannels() == 1) {
            mCarve.setStereo(false);
            stereo->setValueNotifyingHost(false);
        } else {
            mCarve.setStereo(val);
            stereo->setValueNotifyingHost(val);
        }
    }
}

std::vector<juce::String> CarveAudioProcessor::_provideParamNamesForMigration() {
    return std::vector<juce::String> {
        MODE1_STR,
        PREGAIN1_STR,
        POSTGAIN1_STR,
        TWEAK1_STR,

        MODE2_STR,
        PREGAIN2_STR,
        POSTGAIN2_STR,
        TWEAK2_STR,

        ROUTING_STR,
        STEREO_STR,
        DRYLEVEL_STR,
        OUTPUTGAIN_STR
    };
}

void CarveAudioProcessor::_migrateParamValues(std::vector<float>& paramValues) {

    namespace CP = WECore::Carve::Parameters;

    if (paramValues.size() == 12) {
        paramValues[1] = CP::PREGAIN.NormalisedToInternal(paramValues[1]);
        paramValues[2] = CP::POSTGAIN.NormalisedToInternal(paramValues[2]);
        paramValues[3] = CP::TWEAK.NormalisedToInternal(paramValues[3]);

        paramValues[5] = CP::PREGAIN.NormalisedToInternal(paramValues[5]);
        paramValues[6] = CP::POSTGAIN.NormalisedToInternal(paramValues[6]);
        paramValues[7] = CP::TWEAK.NormalisedToInternal(paramValues[7]);

        paramValues[8] = ROUTING.NormalisedToInternal(paramValues[8]);
        paramValues[10] = DRYLEVEL.NormalisedToInternal(paramValues[10]);
        paramValues[11] = OUTPUTGAIN.NormalisedToInternal(paramValues[11]);
    }
}

void CarveAudioProcessor::_onParameterUpdate() {
    mCarve.DSPUnit1.setMode(mode1->get());
    mCarve.DSPUnit1.setPreGain(preGain1->get());
    mCarve.DSPUnit1.setPostGain(postGain1->get());
    mCarve.DSPUnit1.setTweak(tweak1->get());

    mCarve.DSPUnit2.setMode(mode2->get());
    mCarve.DSPUnit2.setPreGain(preGain2->get());
    mCarve.DSPUnit2.setPostGain(postGain2->get());
    mCarve.DSPUnit2.setTweak(tweak2->get());

    mCarve.setRouting(routing->get());
    setStereo(stereo->get());

    mCarve.setDryLevel(dryLevel->get());
    mCarve.setOutputGain(outputGain->get());
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new CarveAudioProcessor();
}
